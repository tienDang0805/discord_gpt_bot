const { getWeatherDescription } = require('../services/weather');
const GptChatService = require('../services/gptChatService');
const ImageGenerationService = require('../services/imageGenerationService');
const { sendLongMessage } = require('../utils/messageHelper');
const TextToAudioService = require('../services/textToAudioService');
const { ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder, EmbedBuilder } = require('discord.js');


module.exports = async (interaction) => {
    if (!interaction.isChatInputCommand()) return;

    const imageGenService = new ImageGenerationService();
    const textToAudioService = new TextToAudioService();

    if (interaction.commandName === 'thoitiet') {
        await interaction.deferReply();
        const weather = await getWeatherDescription();
        await sendLongMessage(
            interaction.editReply.bind(interaction), 
            weather
        );
    }
    
    if (interaction.commandName === 'tool') {
        await interaction.deferReply();
        
        try {
            const searchQuery = interaction.options.getString('query');
            
            if (!searchQuery) {
                return await interaction.editReply('Vui l√≤ng cung c·∫•p t·ª´ kh√≥a t√¨m ki·∫øm!');
            }

            const result = await GptChatService.chatWithSearch(
                interaction.user.id,
                interaction.id,
                searchQuery
            );

            if (result.success) {
                await sendLongMessage(
                    interaction.editReply.bind(interaction),
                    result.response
                );
            } else {
                await interaction.editReply(`L·ªói: ${result.error}`);
            }
        } catch (error) {
            console.error('Search Error:', error);
            await interaction.editReply('ƒê√£ x·∫£y ra l·ªói khi th·ª±c hi·ªán t√¨m ki·∫øm');
        }
    }

    if (interaction.commandName === 'genimage') {
        await interaction.deferReply();
        
        try {
            const prompt = interaction.options.getString('prompt');
            const style = interaction.options.getString('style');
            
            if (!prompt) {
                return await interaction.editReply('Vui l√≤ng cung c·∫•p m√¥ t·∫£ ƒë·ªÉ t·∫°o ·∫£nh!');
            }

            // Th√™m style v√†o prompt n·∫øu c√≥
            const fullPrompt = style 
                ? `${prompt}, ${style} style, high quality, 4k`
                : prompt;

            console.log(`[GenImage] ƒêang t·∫°o ·∫£nh v·ªõi prompt: "${fullPrompt}"`);
            
            const result = await imageGenService.generateImage(fullPrompt);

            if (result.success) {
                console.log(`[GenImage] T·∫°o ·∫£nh th√†nh c√¥ng, k√≠ch th∆∞·ªõc: ${result.imageBuffer.length} bytes`);
                
                await interaction.editReply({
                    content: result.textResponse || `·∫¢nh ƒë∆∞·ª£c t·∫°o t·ª´: "${prompt}"`,
                    files: [{
                        attachment: result.imageBuffer,
                        name: 'generated-image.png'
                    }]
                });
            } else {
                console.error('[GenImage] L·ªói khi t·∫°o ·∫£nh:', result.error);
                await interaction.editReply({
                    content: `‚ùå L·ªói khi t·∫°o ·∫£nh: ${result.error || 'Kh√¥ng x√°c ƒë·ªãnh'}`
                });
            }
        } catch (error) {
            console.error('[GenImage] L·ªói kh√¥ng x·ª≠ l√Ω ƒë∆∞·ª£c:', {
                error: error.message,
                stack: error.stack,
                interaction: {
                    user: interaction.user.tag,
                    options: interaction.options.data
                }
            });
            await interaction.editReply('‚ùå Bot g·∫∑p l·ªói nghi√™m tr·ªçng khi t·∫°o ·∫£nh. Vui l√≤ng th·ª≠ l·∫°i sau!');
        }
    }

    if (interaction.commandName === 'speak') {
        await interaction.deferReply();
        
        try {
            const prompt = interaction.options.getString('prompt');
            if (!prompt) {
                return await interaction.editReply('Vui l√≤ng nh·∫≠p n·ªôi dung c·∫ßn chuy·ªÉn th√†nh audio!');
            }

            console.log(`[Speak] ƒêang t·∫°o audio cho: "${prompt}"`);
            const { text, audioBuffer } = await textToAudioService.generateResponseWithAudio(prompt);
            
            await interaction.editReply({
                content: `N·ªôi dung: ${text}`,
                files: [{
                    attachment: audioBuffer,
                    name: 'audio-response.mp3'
                }]
            });
            console.log('[Speak] ƒê√£ g·ª≠i audio th√†nh c√¥ng');

        } catch (error) {
            console.error('[Speak] L·ªói:', error);
            await interaction.editReply({
                content: `‚ùå L·ªói khi t·∫°o audio: ${error.message}`,
                ephemeral: true
            });
        }
    }

    // Music commands
    if (interaction.commandName === 'play') {
        await interaction.deferReply();
        
        try {
            const { musicService } = interaction.client;
            const voiceChannel = interaction.member?.voice?.channel;
            const url = interaction.options.getString('url');
                console.log("[DEBUG] URL ng∆∞·ªùi d√πng nh·∫≠p:", url); // üëà log ra URL

            if (!voiceChannel) {
                return await interaction.editReply("‚ùå B·∫°n c·∫ßn v√†o voice channel tr∆∞·ªõc!");
            }

            if (!musicService?.play) {
                console.error("[CRITICAL] MusicService.play kh√¥ng t·ªìn t·∫°i!");
                return await interaction.editReply("‚ùå Bot ƒëang g·∫∑p l·ªói h·ªá th·ªëng!");
            }

            const result = await musicService.play(voiceChannel, url, {
                requestedBy: interaction.user.tag
            });

            await interaction.editReply(result.message || "üéµ ƒêang ph√°t nh·∫°c...");
        } catch (error) {
            console.error("[ERROR] /play failed:", error);
            await interaction.editReply(`‚ùå L·ªói: ${error.message}`);
        }
    }

    if (interaction.commandName === 'skip') {
        await interaction.deferReply();
        
        try {
            const { musicService } = interaction.client;
            const guildId = interaction.guild.id;
            
            if (!musicService?.skip) {
                console.error("[CRITICAL] MusicService.skip kh√¥ng t·ªìn t·∫°i!");
                return await interaction.editReply("‚ùå Bot ƒëang g·∫∑p l·ªói h·ªá th·ªëng!");
            }

            const result = await musicService.skip(guildId);
            await interaction.editReply(result.message);
        } catch (error) {
            console.error('Skip Error:', error);
            await interaction.editReply(`‚ùå Error: ${error.message}`);
        }
    }

    if (interaction.commandName === 'stop') {
        await interaction.deferReply();
        
        try {
            const { musicService } = interaction.client;
            const guildId = interaction.guild.id;
            
            if (!musicService?.stop) {
                console.error("[CRITICAL] MusicService.stop kh√¥ng t·ªìn t·∫°i!");
                return await interaction.editReply("‚ùå Bot ƒëang g·∫∑p l·ªói h·ªá th·ªëng!");
            }

            const result = await musicService.stop(guildId);
            await interaction.editReply(result.message);
        } catch (error) {
            console.error('Stop Error:', error);
            await interaction.editReply(`‚ùå Error: ${error.message}`);
        }
    }

    if (interaction.commandName === 'pause') {
        await interaction.deferReply();
        
        try {
            const { musicService } = interaction.client;
            const guildId = interaction.guild.id;
            
            if (!musicService?.pause) {
                console.error("[CRITICAL] MusicService.pause kh√¥ng t·ªìn t·∫°i!");
                return await interaction.editReply("‚ùå Bot ƒëang g·∫∑p l·ªói h·ªá th·ªëng!");
            }

            const result = await musicService.pause(guildId);
            await interaction.editReply(result.message);
        } catch (error) {
            console.error('Pause Error:', error);
            await interaction.editReply(`‚ùå Error: ${error.message}`);
        }
    }

    if (interaction.commandName === 'resume') {
        await interaction.deferReply();
        
        try {
            const { musicService } = interaction.client;
            const guildId = interaction.guild.id;
            
            if (!musicService?.resume) {
                console.error("[CRITICAL] MusicService.resume kh√¥ng t·ªìn t·∫°i!");
                return await interaction.editReply("‚ùå Bot ƒëang g·∫∑p l·ªói h·ªá th·ªëng!");
            }

            const result = await musicService.resume(guildId);
            await interaction.editReply(result.message);
        } catch (error) {
            console.error('Resume Error:', error);
            await interaction.editReply(`‚ùå Error: ${error.message}`);
        }
    }

    if (interaction.commandName === 'queue') {
        await interaction.deferReply();
        
        try {
            const { musicService } = interaction.client;
            const guildId = interaction.guild.id;
            
            if (!musicService?.getQueue) {
                console.error("[CRITICAL] MusicService.getQueue kh√¥ng t·ªìn t·∫°i!");
                return await interaction.editReply("‚ùå Bot ƒëang g·∫∑p l·ªói h·ªá th·ªëng!");
            }

            const { current, queue, repeatMode } = await musicService.getQueue(guildId);
            
            let message = `üîÅ Ch·∫ø ƒë·ªô l·∫∑p: ${repeatMode}\n`;
            
            if (current) {
                message += `üé∂ ƒêang ph√°t: **${current.title}** (Y√™u c·∫ßu b·ªüi: ${current.requestedBy})\n\n`;
            } else {
                message += "üîá Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t\n\n";
            }
            
            if (queue.length > 0) {
                message += "üìÉ Danh s√°ch ch·ªù:\n" + 
                    queue.map((track, index) => 
                        `${index + 1}. **${track.title}** (Y√™u c·∫ßu b·ªüi: ${track.requestedBy})`
                    ).join('\n');
            } else {
                message += "üì≠ Danh s√°ch ch·ªù tr·ªëng";
            }
            
            await interaction.editReply(message);
        } catch (error) {
            console.error('Queue Error:', error);
            await interaction.editReply(`‚ùå Error: ${error.message}`);
        }
    }

    if (interaction.commandName === 'volume') {
        await interaction.deferReply();
        
        try {
            const { musicService } = interaction.client;
            const guildId = interaction.guild.id;
            const volume = interaction.options.getInteger('volume');
            
            if (!musicService?.setVolume) {
                console.error("[CRITICAL] MusicService.setVolume kh√¥ng t·ªìn t·∫°i!");
                return await interaction.editReply("‚ùå Bot ƒëang g·∫∑p l·ªói h·ªá th·ªëng!");
            }

            if (volume === null || volume < 0 || volume > 100) {
                return await interaction.editReply("‚ùå Volume ph·∫£i t·ª´ 0 ƒë·∫øn 100!");
            }

            const result = await musicService.setVolume(guildId, volume);
            await interaction.editReply(result.message);
        } catch (error) {
            console.error('Volume Error:', error);
            await interaction.editReply(`‚ùå Error: ${error.message}`);
        }
    }

    if (interaction.commandName === 'repeat') {
        await interaction.deferReply();
        
        try {
            const { musicService } = interaction.client;
            const guildId = interaction.guild.id;
            const mode = interaction.options.getString('mode');
            
            if (!musicService?.setRepeatMode) {
                console.error("[CRITICAL] MusicService.setRepeatMode kh√¥ng t·ªìn t·∫°i!");
                return await interaction.editReply("‚ùå Bot ƒëang g·∫∑p l·ªói h·ªá th·ªëng!");
            }

            const result = await musicService.setRepeatMode(guildId, mode);
            await interaction.editReply(result.message);
        } catch (error) {
            console.error('Repeat Error:', error);
            await interaction.editReply(`‚ùå Error: ${error.message}`);
        }
    }
    if (interaction.commandName === 'setting') {
        const subcommand = interaction.options.getSubcommand();

        if (subcommand === 'edit') {
            try {
                const config = await GptChatService.getBotConfig();
                const modal = new ModalBuilder()
                    .setCustomId('personality_modal_v2') // ƒê·ªïi ID ƒë·ªÉ tr√°nh xung ƒë·ªôt
                    .setTitle('B·∫£ng ƒêi·ªÅu Khi·ªÉn Nh√¢n C√°ch AI');

                // T·∫†O C√ÅC √î NH·∫¨P LI·ªÜU M·ªöI
                const identityInput = new TextInputBuilder().setCustomId('identity_input').setLabel("Danh t√≠nh (Bot l√† ai?)").setStyle(TextInputStyle.Paragraph).setValue(config.identity);
                const purposeInput = new TextInputBuilder().setCustomId('purpose_input').setLabel("M·ª•c ƒë√≠ch (Bot l√†m g√¨?)").setStyle(TextInputStyle.Paragraph).setValue(config.purpose);
                const hobbiesInput = new TextInputBuilder().setCustomId('hobbies_input').setLabel("S·ªü th√≠ch (Bot th√≠ch g√¨?)").setStyle(TextInputStyle.Paragraph).setValue(config.hobbies);
                const personalityInput = new TextInputBuilder().setCustomId('personality_input').setLabel("T√≠nh c√°ch (H√†nh vi)").setStyle(TextInputStyle.Paragraph).setValue(config.personality);
                const styleInput = new TextInputBuilder().setCustomId('style_input').setLabel("Gi·ªçng vƒÉn (C√°ch n√≥i chuy·ªán)").setStyle(TextInputStyle.Paragraph).setValue(config.writing_style);
                
                // Modal ch·ªâ cho ph√©p 5 ActionRow
                modal.addComponents(
                    new ActionRowBuilder().addComponents(identityInput),
                    new ActionRowBuilder().addComponents(purposeInput),
                    new ActionRowBuilder().addComponents(hobbiesInput),
                    new ActionRowBuilder().addComponents(personalityInput),
                    new ActionRowBuilder().addComponents(styleInput)
                );
                
                await interaction.showModal(modal);
            } catch (error) { /* ... x·ª≠ l√Ω l·ªói ... */ }

        } else if (subcommand === 'view') {
            await interaction.deferReply(); // C√¥ng khai
            const config = await GptChatService.getBotConfig();
            
            const embed = new EmbedBuilder()
                .setColor(0x3d85c6)
                .setTitle('üëÄ Nh√¢n c√°ch hi·ªán t·∫°i c·ªßa AI')
                .setDescription(`Y√™u c·∫ßu b·ªüi: ${interaction.user}`)
                .addFields(
                    { name: 'üìú Danh t√≠nh', value: `\`\`\`${config.identity}\`\`\`` },
                    { name: 'üéØ M·ª•c ƒë√≠ch', value: `\`\`\`${config.purpose}\`\`\`` },
                    { name: 'üé® S·ªü th√≠ch', value: `\`\`\`${config.hobbies}\`\`\`` },
                    { name: 'üë§ T√≠nh c√°ch', value: `\`\`\`${config.personality}\`\`\`` },
                    { name: '‚úçÔ∏è Gi·ªçng vƒÉn', value: `\`\`\`${config.writing_style}\`\`\`` }
                )
                .setTimestamp();
                
            await interaction.editReply({ embeds: [embed] });

        } else if (subcommand === 'reset') {
            await interaction.deferReply();
            await GptChatService.resetBotConfig();
            
            const embed = new EmbedBuilder()
                .setColor(0xFFA500)
                .setTitle('üîÑ Nh√¢n c√°ch AI ƒë√£ ƒë∆∞·ª£c reset!')
                .setDescription(`Ng∆∞·ªùi th·ª±c hi·ªán: ${interaction.user}\n\nƒê√£ quay v·ªÅ c·∫•u h√¨nh m·∫∑c ƒë·ªãnh v√† x√≥a s·∫°ch b·ªô nh·ªõ.`)
                .setTimestamp();

            await interaction.editReply({ embeds: [embed] });
        }
    }
    
};